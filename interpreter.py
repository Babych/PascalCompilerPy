#!/usr/bin/env python3
"""
Three-Address Code Interpreter
Executes the intermediate code generated by the Pascal compiler
"""

import sys
from pathlib import Path

class ThreeAddressInterpreter:
    def __init__(self):
        self.variables = {}
        self.strings = {}
        self.pc = 0  # Program counter
        self.code = []
        
    def load(self, code_lines):
        """Load three-address code"""
        self.code = [line.strip() for line in code_lines if line.strip()]
        
        # Extract string literals
        in_strings = False
        for line in self.code:
            if line == '# String literal data':
                in_strings = True
                continue
            if in_strings and line.startswith('str'):
                # Parse: str0: .string "Hello"
                parts = line.split(':', 1)
                if len(parts) == 2:
                    label = parts[0].strip()
                    value = parts[1].replace('.string', '').strip().strip('"')
                    self.strings[label] = value
    
    def run(self):
        """Execute the code"""
        while self.pc < len(self.code):
            line = self.code[self.pc]
            
            # Skip comments and labels
            if line.startswith('#') or line.endswith(':') or not line:
                self.pc += 1
                continue
            
            # Skip string literal section
            if '# String literal data' in line or line.startswith('str'):
                self.pc += 1
                continue
            
            # Execute instruction
            try:
                self.execute(line)
            except Exception as e:
                print(f"Runtime error at line {self.pc}: {line}")
                print(f"Error: {e}")
                sys.exit(1)
            
            self.pc += 1
    
    def execute(self, instruction):
        """Execute a single instruction"""
        # Halt
        if instruction == 'halt':
            sys.exit(0)
        
        # Write
        elif instruction.startswith('write '):
            value = self.eval_expression(instruction[6:])
            print(value, end='')
        
        # Writeln
        elif instruction == 'writeln':
            print()
        
        # Read
        elif instruction.startswith('read '):
            var = instruction[5:].strip()
            self.variables[var] = int(input())
        
        # Readln
        elif instruction == 'readln':
            pass  # Just consume newline
        
        # Assignment
        elif '=' in instruction:
            parts = instruction.split('=', 1)
            left = parts[0].strip()
            right = parts[1].strip()
            
            # Evaluate right side
            value = self.eval_expression(right)
            
            # Handle array assignment
            if '[' in left:
                # array[index] = value
                array_name = left[:left.index('[')]
                index_expr = left[left.index('[')+1:left.index(']')]
                index = self.eval_expression(index_expr)
                
                if array_name not in self.variables:
                    self.variables[array_name] = {}
                self.variables[array_name][index] = value
            else:
                self.variables[left] = value
        
        # Goto
        elif instruction.startswith('goto '):
            label = instruction[5:].strip()
            self.pc = self.find_label(label) - 1
        
        # Conditional jump
        elif instruction.startswith('if_true '):
            parts = instruction.split()
            condition = self.eval_expression(parts[1])
            if condition:
                label = parts[3]
                self.pc = self.find_label(label) - 1
        
        elif instruction.startswith('if_false '):
            parts = instruction.split()
            condition = self.eval_expression(parts[1])
            if not condition:
                label = parts[3]
                self.pc = self.find_label(label) - 1
        
        # Call (simplified - just skip for now)
        elif instruction.startswith('call '):
            pass
        
        # Return
        elif instruction == 'return':
            pass
    
    def eval_expression(self, expr):
        """Evaluate an expression"""
        expr = expr.strip()
        
        # String literal
        if expr.startswith('str'):
            return self.strings.get(expr, expr)
        
        # Array access
        if '[' in expr:
            array_name = expr[:expr.index('[')]
            index_expr = expr[expr.index('[')+1:expr.index(']')]
            index = self.eval_expression(index_expr)
            return self.variables.get(array_name, {}).get(index, 0)
        
        # Variable
        if expr in self.variables:
            return self.variables[expr]
        
        # Literal number
        if expr.replace('.', '').replace('-', '').isdigit():
            if '.' in expr:
                return float(expr)
            return int(expr)
        
        # Binary operation
        for op in ['==', '!=', '<=', '>=', '<', '>', '&&', '||', '+', '-', '*', '/', '%']:
            if op in expr:
                # Simple split (doesn't handle precedence properly, but works for three-address code)
                parts = expr.split(op, 1)
                if len(parts) == 2:
                    left = self.eval_expression(parts[0].strip())
                    right = self.eval_expression(parts[1].strip())
                    
                    if op == '+': return left + right
                    elif op == '-': return left - right
                    elif op == '*': return left * right
                    elif op == '/': return left // right if isinstance(left, int) else left / right
                    elif op == '%': return left % right
                    elif op == '==': return left == right
                    elif op == '!=': return left != right
                    elif op == '<': return left < right
                    elif op == '<=': return left <= right
                    elif op == '>': return left > right
                    elif op == '>=': return left >= right
                    elif op == '&&': return left and right
                    elif op == '||': return left or right
        
        # Unary operation
        if expr.startswith('!'):
            return not self.eval_expression(expr[1:])
        if expr.startswith('-'):
            return -self.eval_expression(expr[1:])
        
        return 0
    
    def find_label(self, label):
        """Find the line number of a label"""
        for i, line in enumerate(self.code):
            if line.strip() == f"{label}:":
                return i
        return self.pc

def main():
    if len(sys.argv) < 2:
        print("Usage: python interpreter.py <three-address-code-file>")
        sys.exit(1)
    
    code_file = Path(sys.argv[1])
    if not code_file.exists():
        print(f"Error: File '{code_file}' not found")
        sys.exit(1)
    
    # Read code
    with open(code_file, 'r') as f:
        code = f.readlines()
    
    # Run
    interpreter = ThreeAddressInterpreter()
    interpreter.load(code)
    interpreter.run()

if __name__ == '__main__':
    main()
